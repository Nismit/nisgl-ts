<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>GPGPU2 | NISGL Example</title>
  <link rel="icon" type="image/x-icon" href="./assets/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>body { margin: 0; overflow: hidden; }</style>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90679064-4"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-90679064-4');
  </script>
</head>
<body id="triangle">
  <canvas id="canvas"></canvas>
  <script type="module">
    import NISGL from "./assets/nisgl.module.js";
    import { mat4 } from "https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/esm/index.js";
    const curlNoise = `
    //
    // Description : Array and textureless GLSL 2D/3D/4D simplex
    //               noise functions.
    //      Author : Ian McEwan, Ashima Arts.
    //  Maintainer : stegu
    //     Lastmod : 20110822 (ijm)
    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
    //               Distributed under the MIT License. See LICENSE file.
    //               https://github.com/ashima/webgl-noise
    //               https://github.com/stegu/webgl-noise
    //

    vec3 mod289(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 mod289(vec4 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 permute(vec4 x) {
        return mod289(((x*34.0)+1.0)*x);
    }

    vec4 taylorInvSqrt(vec4 r)
    {
      return 1.79284291400159 - 0.85373472095314 * r;
    }

    float snoise(vec3 v)
      {
      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

      // First corner
      vec3 i  = floor(v + dot(v, C.yyy) );
      vec3 x0 =   v - i + dot(i, C.xxx) ;

      // Other corners
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min( g.xyz, l.zxy );
      vec3 i2 = max( g.xyz, l.zxy );

      //   x0 = x0 - 0.0 + 0.0 * C.xxx;
      //   x1 = x0 - i1  + 1.0 * C.xxx;
      //   x2 = x0 - i2  + 2.0 * C.xxx;
      //   x3 = x0 - 1.0 + 3.0 * C.xxx;
      vec3 x1 = x0 - i1 + C.xxx;
      vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
      vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

      // Permutations
      i = mod289(i);
      vec4 p = permute( permute( permute(
                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

      // Gradients: 7x7 points over a square, mapped onto an octahedron.
      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
      float n_ = 0.142857142857; // 1.0/7.0
      vec3  ns = n_ * D.wyz - D.xzx;

      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

      vec4 x = x_ *ns.x + ns.yyyy;
      vec4 y = y_ *ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);

      vec4 b0 = vec4( x.xy, y.xy );
      vec4 b1 = vec4( x.zw, y.zw );

      //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
      //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));

      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

      vec3 p0 = vec3(a0.xy,h.x);
      vec3 p1 = vec3(a0.zw,h.y);
      vec3 p2 = vec3(a1.xy,h.z);
      vec3 p3 = vec3(a1.zw,h.w);

      //Normalise gradients
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;

      // Mix final noise value
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                    dot(p2,x2), dot(p3,x3) ) );
      }

    vec3 snoise3D(vec3 pos){
      vec3 res;
      res.x = snoise(pos + vec3(0.0,1.0,3.0));
      res.y = snoise(pos - vec3(5.0,1.0,3.0));
      res.z = snoise(pos + vec3(4.0,5.0,3.0));
      return res;
    }

    vec3 snoiseVec3( vec3 x ){
      float s  = snoise(vec3( x ));
      float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));
      float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));
      vec3 c = vec3( s , s1 , s2 );
      return c;
    }

    vec3 curlNoise( vec3 p ){
      const float e = .1;
      vec3 dx = vec3( e   , 0.0 , 0.0 );
      vec3 dy = vec3( 0.0 , e   , 0.0 );
      vec3 dz = vec3( 0.0 , 0.0 , e   );

      vec3 p_x0 = snoiseVec3( p - dx );
      vec3 p_x1 = snoiseVec3( p + dx );
      vec3 p_y0 = snoiseVec3( p - dy );
      vec3 p_y1 = snoiseVec3( p + dy );
      vec3 p_z0 = snoiseVec3( p - dz );
      vec3 p_z1 = snoiseVec3( p + dz );

      float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
      float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
      float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;

      const float divisor = 1.0 / ( 2.0 * e );
      return normalize( vec3( x , y , z ) * divisor );
    }
    `;

    const Vertex = `
    precision highp float;

    attribute float randDir;
    attribute float index;
    uniform float num;
    uniform sampler2D posTexture;
    uniform mat4 mvpMatrix;
    // uniform float time;

    varying vec3 vColor;
    varying float alpha;

    void main(){
      vec2 texPos = vec2(
        mod(index, num) / num,
        floor(index / num) / num
      );
      vec3 pos = texture2D(posTexture,texPos).xyz;
      // alpha = texture2D(posTexture, texPos).w / 100.0;
      // alpha = texture2D(posTexture, texPos).w / 50.0;
      alpha = texture2D(posTexture, texPos).w;
      gl_Position = mvpMatrix * vec4(pos * 1.0, 1.0);
      gl_PointSize = 2.0;

      vColor = vec3(1.0);
    }`;

    const Fragment = `
    precision highp float;

    varying vec3 vColor;
    varying float alpha;
    void main(){
      gl_FragColor = vec4(vColor, alpha);
    }`;

    const renderVertex = `
    attribute vec3 position;
    void main(){
      gl_Position = vec4(position, 1.0);
    }`;

    const initialVertex = `
    attribute float randDir;
    attribute vec3 position;
    uniform mat4 mvpMatrix;

    varying float random;
    void main(){
      random = randDir;
      gl_Position = vec4(position, 1.0);
    }`;

    const initParticleFragment = `
    precision highp float;
    uniform vec2 resolution;
    varying float random;

    void main(){
      vec2 p = (gl_FragCoord.xy / resolution) * 2.0 - 1.0;
      float pct = distance(p,vec2(0.));
      // gl_FragColor = vec4(p, 0.0, 0.0);
      // gl_FragColor = vec4(vec3(p * 0.2, 0.9), 0.0);
      gl_FragColor = vec4(p, 0.0, 0.0);
    }`;

    const computeParticleFragment = `
    precision highp float;

    uniform sampler2D fixedTexture;
    uniform sampler2D posTexture;
    uniform vec2 resolution;
    uniform float time;

    ${curlNoise}

    void main(){
      vec2 uv = gl_FragCoord.xy / resolution;
      vec3 pos = texture2D(posTexture, uv).xyz;
      vec3 copy = texture2D(posTexture, uv).xyz;
      float life = texture2D(posTexture, uv).w;
      float far = 4.0;

      vec3 vel = 0.0125 * curlNoise(.5 * pos);
      pos += vel;

      life = 0.9 - (distance(pos, vec3(0.)) / far);
      // life = distance(pos, vec3(0.)) / far;

      if(distance(pos, vec3(0.)) > far) {
        pos = texture2D(fixedTexture, uv).xyz;
      }

      gl_FragColor = vec4(pos, life);
    }`;

    const canvas = document.querySelector("#canvas");
    canvas.width = document.documentElement.clientWidth;
    canvas.height = window.innerHeight;
    const gl = canvas.getContext("webgl");
    const nisgl = new NISGL(gl);

    // Enable extension
    const ext = gl.getExtension('OES_texture_float') || gl.getExtension('OES_texture_half_float');
    if (ext == null) {
      alert('float texture not supported');
    }

    // Event
    let mouseFlag = false;
    let mousePositionX = 0.0;
    let mousePositionY = 0.0;
    canvas.addEventListener('mousedown', mouseDown, true);
    canvas.addEventListener('mouseup', mouseUp, true);
    canvas.addEventListener('mousemove', mouseMove, true);

    // Clear
    nisgl.clear();

    // Data
    const TEX_WIDTH = 512;
    const TEX_HEIGHT = 512;

    const particleIndex = [];
    const randomDirections = [];

    for(let i = 0; i < TEX_WIDTH; i++) {
      for(let j = 0; j < TEX_HEIGHT; j++) {
        particleIndex.push(i + j * TEX_WIDTH);
        randomDirections.push(Math.floor(Math.random() * 10) + 1);
      }
    }

    // prettier-ignore
    const screen_vertex = [
      - 1.0,   1.0, 0.0,
        1.0,   1.0, 0.0,
      - 1.0, - 1.0, 0.0,
        1.0, - 1.0, 0.0
		];

    const screen_index = [
			0, 1, 2, 3, 2, 1
		];

    // Create a program
    const sceneProgram = nisgl.createProgram(Vertex, Fragment);
    const initParticleProgram = nisgl.createProgram(initialVertex, initParticleFragment);
    const particleProgram = nisgl.createProgram(renderVertex, computeParticleFragment);

    const particleBuffer = nisgl.arrayBuffer(new Float32Array(particleIndex));
    particleBuffer.attrib("index", 1);
    const screenPositionBuffer = nisgl.arrayBuffer(new Float32Array(screen_vertex));
    screenPositionBuffer.attrib("position", 3);
    const screenIndexBuffer = nisgl.indexBuffer(new Int16Array(screen_index));

    const randomDirectionBuffer = nisgl.arrayBuffer(new Float32Array(randomDirections));
    randomDirectionBuffer.attrib("randDir", 1);


    // Camera
    const mMatrix = mat4.create();
    const vMatrix = mat4.identity(mat4.create());
    const pMatrix = mat4.create();
    const tmpMatrix = mat4.create();
    const mvpMatrix = mat4.create();

    mat4.lookAt(vMatrix, [0.0, 2.0, 5.0], [0, 0, 0], [0, 1.0, 0]);
    mat4.perspective(pMatrix, 45, canvas.width / canvas.height, 0.1, 100);
    mat4.multiply(tmpMatrix, pMatrix, vMatrix);

     // Uniforms
    let velocity = 0;
    let counter = 0;
    let time = 0;

    // Framebuffer
    let fixedBuffer = nisgl.createFrameBuffer(TEX_WIDTH, TEX_HEIGHT);
    fixedBuffer.attachTexture(gl.getExtension( 'OES_texture_half_float' ).HALF_FLOAT_OES, true);
    let backBuffer = nisgl.createFrameBuffer(TEX_WIDTH, TEX_HEIGHT);
    backBuffer.attachTexture(gl.getExtension( 'OES_texture_half_float' ).HALF_FLOAT_OES, true);
    let frontBuffer = nisgl.createFrameBuffer(TEX_WIDTH, TEX_HEIGHT);
    frontBuffer.attachTexture(gl.getExtension( 'OES_texture_half_float' ).HALF_FLOAT_OES, true);
    let flipBuffer = null;

    // gl.activeTexture(gl.TEXTURE0);
    // gl.disable(gl.BLEND);
    // gl.blendFunc(gl.ONE, gl.ONE);

    // Init backBuffer
    backBuffer.bind();
    gl.viewport(0, 0, TEX_WIDTH, TEX_HEIGHT);
    nisgl.clear();
    initParticleProgram.use();
    randomDirectionBuffer.attribPointer(initParticleProgram);
    screenPositionBuffer.attribPointer(initParticleProgram);
    initParticleProgram.setUniform("Matrix4fv", "mvpMatrix", mvpMatrix);
    initParticleProgram.setUniform("2fv", "resolution", [TEX_WIDTH, TEX_HEIGHT]);
    screenIndexBuffer.bind();
    screenIndexBuffer.drawTriangles(screen_index.length, 0);
    backBuffer.unbind();

    fixedBuffer.bind();
    nisgl.clear();
    initParticleProgram.use();
    randomDirectionBuffer.attribPointer(initParticleProgram);
    screenPositionBuffer.attribPointer(initParticleProgram);
    initParticleProgram.setUniform("Matrix4fv", "mvpMatrix", mvpMatrix);
    initParticleProgram.setUniform("2fv", "resolution", [TEX_WIDTH, TEX_HEIGHT]);
    screenIndexBuffer.bind();
    screenIndexBuffer.drawTriangles(screen_index.length, 0);

    function render() {
      time += 0.001666;
      const rad = ((counter % 360) * Math.PI) / 180;


      // Front Buffer
      gl.disable(gl.BLEND);
      frontBuffer.bind();
      nisgl.clear();
      gl.viewport(0, 0, TEX_WIDTH, TEX_HEIGHT);

      particleProgram.use();
      screenPositionBuffer.attribPointer(particleProgram);

      gl.activeTexture(gl.TEXTURE0);
      const backTex = backBuffer.getTexture();
      backTex.bind();

      gl.activeTexture(gl.TEXTURE1);
      const fixedTex = fixedBuffer.getTexture();
      fixedTex.bind();

      particleProgram.setUniform("2fv", "resolution", [TEX_WIDTH, TEX_HEIGHT]);
      particleProgram.setUniform("1i", "posTexture", 0);
      particleProgram.setUniform("1i", "fixedTexture", 1);
      particleProgram.setUniform("1f", "time", time);
      screenIndexBuffer.bind();
      screenIndexBuffer.drawTriangles(screen_index.length, 0);

      // Enable Fragment alpha color
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
      gl.enable(gl.BLEND);
      gl.viewport(0, 0, canvas.width, canvas.height);
      frontBuffer.unbind();
      nisgl.clear(0.035, 0.019, 0.141);

      mat4.identity(mMatrix);
      mat4.rotate(mMatrix, mMatrix, rad, [0.0, 1.0, 0.0]);
      mat4.multiply(mvpMatrix, tmpMatrix, mMatrix);

      sceneProgram.use();

      gl.activeTexture(gl.TEXTURE0);
      const frontTex = frontBuffer.getTexture();
      frontTex.bind();

      sceneProgram.setUniform("1i", "posTexture", 0);
      sceneProgram.setUniform("1f", "time", time);
      sceneProgram.setUniform("1f", "num", TEX_WIDTH);
      sceneProgram.setUniform("Matrix4fv", "mvpMatrix", mvpMatrix);
      randomDirectionBuffer.attribPointer(sceneProgram);
      particleBuffer.attribPointer(sceneProgram);
      particleBuffer.drawPoints(0, particleIndex.length);

      nisgl.flush();

      if (mouseFlag) {
        velocity = 1.0;
      } else {
        velocity *= 0.95;
      }

      flipBuffer = backBuffer;
      backBuffer = frontBuffer;
      frontBuffer = flipBuffer;

      counter += 0.1;
    }

    function renderLoop() {
      render();
      requestAnimationFrame(renderLoop);
    }
    renderLoop();

    function mouseDown(eve){
      mouseFlag = true;
    }

    function mouseUp(eve){
      mouseFlag = false;
    }

    function mouseMove(eve){
      if(mouseFlag){
        var cw = canvas.width;
        var ch = canvas.height;
        mousePositionX = (eve.clientX - canvas.offsetLeft - cw / 2.0) / cw * 2.0;
        mousePositionY = -(eve.clientY - canvas.offsetTop - ch / 2.0) / ch * 2.0;
      }
    }

    function keyDown(eve){
      run = (eve.keyCode !== 27);
    }

  </script>
</body>
</html>
